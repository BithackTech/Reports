### 摘要
智能合约使相互不受信任的实体能够在不依赖可信第三方的情况下进行交互。
尽管存在潜力，但一再出现的安全问题已经动摇了通过智能合约处理数十亿美元的信任。
为了解决这个问题，我们推出了Securify，这是一个可以扩展，完全自动化的以太坊智能合约的安全分析器，能够证明合约行为对于给定的财产是安全/不安全的。 Securify的分析包括两个步骤。首先，它符号化地分析合约的依赖图，从代码中提取精确的语义信息。然后，它会检查合规性和违规模式，以捕获足够的条件来证明财产是否成立。要启用可扩展性，所有模式都以指定的特定于域的语言指定。
Securify是公开发布的，它已经分析了其用户提交的超过18,000份合约，并且经常用于执行安全性专家审核。我们对Securify进行了对现实世界以太坊智能合约的广泛评估，并证明它可以有效地证明智能合约的正确性并发现严重违规行为。

### 关键词
智能合约;安全分析;分层数据记录

# 1 引言
区块链平台，如中本聪的比特币，可以在互不信任的各方之间进行加密货币交易。为了消除对信任的需求，中本聪设计了一个点对点网络，使其同行能够就交易交易达成一致。 Vitalik Buterin确定了分散计算在交易之外的适用性，并设计了以太坊区块链，该区块链支持程序的执行，称为智能合约，用图灵完整语言编写。智能合约已经证明适用于许多领域，包括金融业，公共部门和跨行业。
智能合约的采用越来越多，需要强大的安全保障。不幸的是，创建没有安全漏洞的智能合约是一项挑战。因此，智能合约中的关键漏洞每隔几个月就被发现和利用。反过来，这些漏洞导致在过去几年中损失达到数百万美元：2016年6月从流行的DAO合约中偷走了1.5亿，2017年7月份广泛使用的Parity多签名钱包中有3千万美元被盗，几个月后因为同一个钱包中的一个错误而冻结了2.8亿美元。很明显，迫切需要有效的智能合约安全检查员。
### 主要挑战
为智能合约创建有效的安全分析器的主要挑战是编程语言的图灵完备性，这使得任意属性的自动验证不可判定。**为了解决这个问题，目前的自动化解决方案往往依赖于相当通用的测试和符号执行方法**（例如，Oyente 和Mythril）。虽然在某些情况下有用，但这些方法有几个缺点：
* 他们可能错过严重违规行为（由于近似不足）。
* 然而，也可能产生误报（由于特定领域元素的不精确建模[3]）
* 它们未能在现实合约上实现足够的代码覆盖率（Oyente在流行的Parity钱包上的覆盖率仅为20.2％）。

总的来说，这些缺点给用户带来了沉重的负担，他们必须检查所有报告是否存在误报并担心未报告的漏洞。 实际上，智能合约的许多安全属性本身很难直接推理。 解决这些挑战的可行途径是构建一个针对特定领域特定属性的自动验证程序。 例如，最近的工作仅侧重于识别智能合约中的重入问题。
### 特定领域的观测
对这项工作的一个重要观察是，通常可以设计在合约的数据流图上表达的精确模式，其中模式的匹配意味着违反或满足原始安全属性。 例如，通过匹配一个表明调用没有写入存储的模式，可以证明以太坊智能合约中90.9％的所有调用都没有臭名昭着的DAO错误[6]。 可以建立这种对应关系的原因是，在现实世界合约中违反原始财产往往会违反更简单的财产（由模式捕获）。 实际上，在验证方面，使用**模式而不是相应属性的关键优势在于模式更适合自动推理**。
### Securify：特定于域的验证程序
基于上述观点，我们开发了Securify，这是一款适用于以太坊智能合约的轻量级，可扩展的安全验证器。 关键技术思想是定义镜像给定安全属性的两种模式：
（i）遵守模式，意味着财产的满足
（ii）违反模式，这意味着它的否定。 为了检查这些模式，Securify在分层数据记录[50]中象征性地编码合约的依赖图，并利用现成的可扩展Datalog解算器有效地（通常在几秒钟内）分析代码。 为了确保可扩展性，所有模式都以指定的域特定语言（DSL）表示
![图片](https://images-cdn.shimo.im/8YWm5MHlHH0WeHYG/image.png!thumbnail)

>图1：Securify方法基于语义程序事实的自动推断，
>然后检查这些事实的合规性和违规安全模式

在图1中，我们说明了Securify的分析流程。 从合约的字节码（或源代码，可编译为字节码）开始，Securify通过分析合约的依赖图来推导出语义分析，并使用这些事实来检查一组合规性和违规模式。 

根据这些检查的结果，Securify将所有合约行为分为
违规（◆）
警告（▲）
合规（■）

如图2中抽象所示。这里，大框描绘了所有合约行为，分为安全（满足属性）和不安全（违反它）。 Securify报告违规（◆）与违规模式匹配的所有行为，以及警告（▲）合规模式无法比拟的所有剩余行为。

### 减少手动努力 
与智能合约的现有符号分析器相比，Securify减少了以两种方式检查报告所需的工作量。首先，现有的分析仪不会报告明确的违规行为（它们会混淆◆和▲），因此要求用户手动将所有报告的漏洞分类为真阳性（在红色框中找到）或误报（在绿色框中找到）。相反，Securify会自动对保证违规的行为进行分类（标有◆）。
![图片](https://images-cdn.shimo.im/Ms0FIGrEHKQPS0Bg/image.png!thumbnail)

因此，用户仅需要手动将警告（▲）分类为真或假阳性。
正如我们在评估中所表明的那样，使用违规和合规模式的方法将用户手动检查的警告减少了65.9％，某些特性甚至高达99.4％。其次，现有分析仪无法报告不安全行为（有时高达72.9％），这意味着用户可能必须手动检查分析仪未覆盖的部分代码。相比之下，Securify报告所有不安全的行为。

### 审核智能合约
[https://securify.chainsecurity.com/](https://securify.chainsecurity.com/)
在过去的一年中，我们还广泛使用Securify对智能合约进行了38次详细的商业审计（其他审计师也使用了Securify），反复改进方法并添加更多模式。
实际上，Securify的设计和实施从这一经验中获益匪浅。就实际审计流程而言，我们的方法（我们相信其他审计员）已经运行所有可用工具，然后手动检查报告的漏洞，以评估其严重性。例如，虽然Securify涵盖了许多重要属性（完整版支持18个属性），但符号执行工具可以更好地支持数值属性（例如，溢出）。我们的发现是，Securify对审计更大的合约特别有帮助，因为前面列出的原因，现有解决方案难以检查。总体而言，我们认为Securify在分析智能合约的过程中是一个务实且有价值的观点，因为它在可扩展性，保证和精确度方面取得了谨慎的平衡
### 主要贡献
总而言之，我们的主要贡献是：
* 一个反编译器，它在Datalog（第4节）中象征性地编码以太坊契约的依赖图。
*  一组合规和违规安全模式，捕获足够的条件来证明和反驳实际的安全属性（第5节）。
* 称为Securify的端到端实施，完全自动化合约分析（第6节）。
* 对现有的以太坊智能合约进行广泛评估，表明Securify可以有效地证明合约的正确性并发现违规行为（第7节）。
# 2 案例
在本节中，我们通过两个2017年影响价值2亿美元的现实安全问题来解决我们解决的问题。我们描述了潜在的安全属性以及证明合约是否满足/违反的相关挑战
他们。 我们还描述了Securify如何通过适当的违规模式发现这两个漏洞。
## 2.1窃取Ether
![图片](https://images-cdn.shimo.im/8LyYDNphwKMJZtXT/image.png!thumbnail)
>图3：一个易受攻击的钱包，允许任何用户撤回存储在其中的所有ether。

该钱包有一个字段 owner，用于存储钱包所有者的地址。 此外，契约有一个函数initWallet，它将地址 _owner 作为参数，并用它初始化字段 owner。 该函数由构造函数调用（图3中未示出），并假设不可访问[10]。 最后，契约有一个函数 withdraw，它将一个无符号整数 _amount作为参数。 该函数检查事务发送者的地址（由 msg.sender 返回）是否等于合约所有者的地址（存储在字段所有者中）。 如果此检查成功，则使用语句owner.transfer（_amount）将_amount ether传输给所有者;
 否则，没有转移Ether。 撤销功能确保只有所有者才能从钱包中提取以太币。
### 攻击
图3中所示的钱包具有严重的安全漏洞：任何用户实际上都可以调用initWallet函数并在字段owner中存储任意地址。 因此，攻击者可以分两步窃取存储在钱包中的所有ether。 首先，攻击者调用函数initWallet，将自己的地址作为参数传递。 其次，攻击者调用函数withdraw，作为参数传递存储在钱包中的以太币量。 我们注意到在攻击Parity的钱包时，为了执行第一步，攻击者利用一个回退机制来调用initWallet函数; 为简单起见，我们省略了这些细节，并请读者[10]了解实际攻击的详细信息。
### 安全财产
允许攻击者窃取以太网的潜在安全问题是，安全关键字段owner是任何以太坊用户都可以普遍写入的。此安全问题反映了一个更通用的属性，规定对owner字段的写入受到限制，因为并非所有用户都可以进行写入此字段的事务。为了表明此属性已满足，我们需要证明某些用户无法发送修改所有者字段的事务。相反，为了显示违规行为，我们需要证明所有用户都可以发送修改所有者字段的交易。 由于可能的用户和交易空间巨大，证明满意和证明违反此属性的行为是非常重要的。
### 发现
为了发现这个安全问题，Securify提供了一个违规模式，该模式将匹配 在图3中以红色突出显示的赋值owner= _owner的执行不依赖于调用者指令返回的值（返回交易发件人的地址）的情况。为了检查这种模式，Securify通过分析合约的依赖关系图来推断数据和控制流的依赖关系。 在这里，Securify推断赋值owner= _owner不依赖于调用者指令，这意味着任何用户都可以访问该指派。
在第3节中，我们提供了有关此违规模式的更多详细信息，以及有关Securify如何使用它来检测漏洞的更多详细信息。
我们注意到一些符号检查器执行类似属性的不精确检查，这导致误报和误判。 例如，正如我们在评估员的图13中所示，Mythril [16]在检查时有大约65％的漏报率。规定并非所有用户都可以触发特定的ether转移。

## 2.2 冻结资金
![图片](https://images-cdn.shimo.im/lPH4xJ5WHXkrLYkO/image.png!thumbnail)
>图4：将功能委托给库合约walletLibrary的钱包

在图4中，我们展示了一个钱包实现，该安全问题在2017年11月遭遇了数百万美元的安全问题。这个钱包有一个字段walletLibrary，它存储实现公共钱包功能的合约的地址。 此外，它还有一个功能存款，标记为应付款，这意味着用户可以通过调用此功能将以太币发送给合约。 函数存放记录由事务发送方（由msg.sender标识）发送的Ether（由msg.value标识）的数量。 最后，合约有一个函数withdraw，它将所有调用委托给钱包库。 也就是说，语句walletLibrary.delegatecall（msg.data）导致在当前钱包的上下文中执行钱包库的撤销方法。
### 攻击
可以使用指定的kill指令从区块链中删除以太坊契约。 如果攻击者可以从区块链中删除钱包库，则无法从钱包中提取钱包中的资金。 这是因为钱包依赖库智能合约撤销Ether。 2017年11月，一个流行的钱包库从区块链中删除，有效冻结了价值约2.8亿美元的ether[7]。
### 安全财产
这个钱包的潜在安全问题是它允许用户存入Ether，但它不能保证Ether可以转出合约，因为转移依赖于库。 为了发现钱包有这个问题，我们必须证明两个事实：
（i）用户可以存入Ether;
（ii）合约没有以非零数量的ETH的以太转移指令（即通话）。
 请注意，如果合约仅通过库传输Ether，则满足第二个要求。
### 发现
为了发现此漏洞，Securify的违规模式检查两个事实的结合。 首先，为证明用户可以存入Ether，Securify会检查是否存在执行不依赖于Ether传输的零停止指令。 假设某些交易可以达到停止指令，这意味着用户可以用正的Ether币量到达它，从而导致合约存入Ether。 其次，Securify检查是否所有呼叫指令，从合约中提取的Ether为零。 这两个事实的结合意味着Ether可以被锁定在合约中。
# 3 安全系统
在上一节中，我们说明了虽然智能合约中的安全问题很复杂，但通常可以使用从代码中推断出的语义分析来捕获它们。 在本节中，我们描述了Securify系统，该系统以此思想为基础，用于证明和反驳智能合约的安全属性。 我们在此部分中提供了Securify如何检测钱包合约中对owner字段的无限制写入的示例（图3）。 图5总结了主要步骤。 
![图片](https://images-cdn.shimo.im/biGBhqpsCQ0oZhxi/image.png!thumbnail)
>图5：高级别说明了Securify如何将无限制写入从图3中的合约owner的数据域中删除。输入（EVM字节码和安全模式）以绿色突出显示，输出（在我们的示例中，是违反的指令） ）以红色突出显示，灰色框表示中间分析工件。 Securify分三步进行：
>（1）它将合约的EVM字节码反编译为静态单一赋值形式
>（2）它推断出有关合约的语义分析
>（3）它匹配写入所有者数据域的sstore指令上的受限写入属性的违规模式
### 输入到Securify
Securify的输入是合约的EVM字节码和一组安全模式，在我们指定的域特定语言（DSL）中指定。 Securify还可以将以Solidity（未在图5中显示）中编写的输入合约作为输入合约，在进行分析之前将其编译为EVM字节码。 有两种安全模式：合规性和违规模式，它们捕获足够的条件以确保合约满足并分别违反给定的安全属性。 图5以绿色方框示出了Securify的输入，其中显示了钱包合约的EVM字节码的一部分（仅说明漏洞所需的部分）和受限写入属性的违规模式。 直观地，如果存在不受限制的写入，则匹配模式
为了发现合约中的无限制写入，Securify继续执行以下三个步骤
### 第1步：反编译EVM字节码
Securify frst将作为输入提供的EVM字节码转换为静态单一赋值形式（SSA）中的无堆栈表示。 例如，在图5中，对于堆栈表达式push 0x04，Securify引入了局部变量a和赋值语句a = 4.除了删除堆栈之外，Securify还识别方法。 例如，图5中所示的方法ABI_9DA8对应于钱包合约的initOwner方法，如图3所示。反编译后，Securify执行部分评估以解析内存和存储集，跳转目的地，所有这些都是 对于静态地精确分析代码很重要。 我们在第6节中描述了这些优化
### 第2步：推断语义分析
在反编译之后，Securify分析合约以推断语义分析，包括数据和控制 -f依赖关系，这些事实包含了合约的所有行为。例如，如图5所示，事实MayDepOn（b，dataload）捕获变量b的值可能取决于指令dataload返回的值。此外，事实Eq（c，0）捕获变量c等于常数0. Securify的语义分析的推导在分层Datalog中以声明方式指定，并且使用现有的可扩展引擎完全自动化[36]。声明性方法的主要好处是：（i）引用规则简明地捕获关于不同组件的抽象推理（例如，合约存储），（ii）可以容易地添加更多事实和推理规则，以及（iii）指定推理规则以模块化方式（例如，独立于合约存储分析指定存储器分析）。我们在第4节列出了Securify推导出的语义分析以及推理规则
### 第3步：检查安全模式
在获得语义分析后，Securify会检查一组合规性和违规安全模式，作为输入。 这些模式使用专门的领域特定语言（DSL）编写，使安全专家能够利用其定制模式扩展我们的内置模式集。我们的DSL是由Securify推断的语义分析的逻辑公式的片段。 为了检测图3合约中的漏洞，Securify在图5中标签l6处的sstore（c，b）指令上匹配违规模式（给定为输入）。在sstore（c，b）中，c是 所有者字段的存储偏移量，b是要存储的值。 如果存在一些sstore指令，则违规模式匹配，其中表示为X的存储偏移量和由其标签L标识的该指令的执行在任何可能的合约执行中都不依赖于调用者指令的结果。 由于指令调用者检索事务发送者的地址，因此匹配此模式意味着任何用户都可以访问此sstore并更改所有者的值。 在我们的DSL中，否定由¬和∧的连接编码，这种模式编码为：
*some *sstore(*L*, *X *, _). ¬*MayDepOn*(*X *, caller)∧¬*MayDepOn*(*L*, caller)
Securify的DSL对于可扩展性非常重要：添加新的安全模式相当于在DSL中指定它们。 为了说明DSL的表现力，我们在第5节中介绍了一系列重要属性的安全模式，例如限制写入，异常处理，以太流动性，输入验证等。 我们注意到安全专家有时会在进行安全审计时添加合约特定模式。 例如，通常需要检查是否存在不良依赖关系，例如：只有所有者可以修改存储中的某些值，或者确保特定算术表达式的结果不依赖于除法指令 （这可能导致不希望的整数舍入效应）。 我们将说明如何在第5节中的DSL中指定这种合约特定模式。
### Securify的输出
对于违规模式的任何匹配，Secu- rify输出导致模式匹配的指令。 在我们的示例中，它突出显示了指令sstore（c，b）。 我们注意到，如果提供了源代码，则该指令的开头可以很容易地映射到Solidity代码中的相应行。 此外，对于违规和合规模式均未匹配的任何财产，Securify会发出警告，表明其未能证明或反驳财产
### 限制
我们简要总结了安全的几个局限性。首先，Securify的当前版本不能推断数字属性，例如overfows。为了解决这一限制，我们计划通过数值分析（例如，使用ELINA [48]）扩展Securify，这不仅可以提高安全性的精确度，还可以检查数值属性。其次，Securify没有推理可达性，并且假设合约中的所有指令都可以到达。这种假设对于在Securify支持的安全属性与用于证明和反驳它们的模式之间建立正式对应关系是必要的。例如，在我们的示例中，Securify假定某些执行可以访问匹配的sstore指令（否则，没有违规）。最后，我们考虑捕获的属性可以被攻击者利用，但不一定会被攻击者利用。例如，合约中有些字母必须是所有用户都可以普遍写入的。为了解决这个问题，安全专家可以在Securify的DSL中编写合约特定模式（例如，指定哪些数据域是敏感的。
# 4 语义分析
在本节中，我们将介绍Securify采用的控制和数据流依赖关系的自动推断。 在此过程中推断的事实称为语义分析，稍后用于检查安全属性。 我们从理解此分析所需的背景开始：EVM指令集和分层数据记录。 然后，我们介绍Securify派生的语义分析和分层数据记录中指定的声明性推理规则，用于推导它们。
## 4.1背景
### 4.1.1以太坊虚拟机（EVM）
### 4.1.2 分层数据记录
参考数据库等
句法
语义
## 4.2 数据和推理规则
Securify首先提取一组适用于每条指令的基本事实。 这些基本事实构成了一个数据记录输入，它被输入Datalog程序以推断关于契约的其他事实我们使用术语语义分析来指代由目录程序导出的事实。 出现在合约中的所有程序元素（包括指令标签，变量，字段，字符串和整数常量）在数据记录程序中表示为常量。
![图片](https://images-cdn.shimo.im/xNEerCHQcEEbKM0k/image.png!thumbnail)
>图7：语义分析：L1和L2是标签，Y是变量，T是标签（变量或标签）。

Securify分析这种合约代码，是从两个维度，第一个是逻辑，第二个是数据。
在逻辑方向的话，它定义了两种逻辑，第一个叫MayFollow，第二叫MustFollow。MayFollow的意思是说L2是有一条路径是跟在L1后面的，而MustFollow是说L2每一条路径都跟在L1后面。这两种区别定了它整个逻辑的一个框架。

>第一个就是它的一个数据，它怎么定义合约里面的数据变化？分了三种，第一种是MayDepOn，就是两个因素，一个叫Y、一个叫T，T变Y可能变也可能不变。
>第二个就是Eq，就是说Y是由T来决定的
>第三个就是大家把DetBy和Y和T是一一对应的，只要T变Y就肯定要变了。

这里面就用更加形象的方法，我们想象一下，MayDepOn就是，变量是T，在一段时间当中Y可能是一个值，然后有的说T变Y可能不变，第三个DetBy就是说一对一的关系，就比如说我们知道哈希，哈希如果T变，Y就肯定要变。
![图片](http://5b0988e595225.cdn.sohucs.com/images/20180930/19dc168c86764db88544c6340b42df39.jpeg)
通过逻辑和数据这两个维度进行了一些验证，最终验证模块的话，现在提供了大概六七个智能合约漏洞的验证性的语言，而且这种语言都是以插件化的形式来写的，其他的安全开发者可以不断去丰富这个漏洞的验证语言，最终我们在对自动化审计进行一个评估的时候，我们其实是要从它的自动化程度，漏报率、误报率来评估这件事情的。
像我们现在知道的一些数据就可以表明出来，其实像Mythril跟Oyente，它里面存在大量的误报，比如说它检测出来的数据还是需要人工进行二次确认，这个工作其实是非常繁琐，而Securify这种方法可能误报率会降低。
### 这也是两种比较现在比较流行的符号执行和抽象的自动化审计方法。
### 


# 5 安全模式
在本节中，我们将展示如何在语义分析上表达安全模式。 我们首先定义Securify语言来表达安全模式。 然后，为了正式定义安全属性，我们提供了有关EVM合约执行语义的背景知识，并正式定义了属性。 我们继续提出一组相关的安全属性，对于每个属性，我们都会显示合规性和违规模式，这些模式暗示了属性以及它们的否定。 这种结构使我们能够确定合约是否符合或违反给定的安全财产。 最后，我们展示了Securify如何利用一些模式进行错误定位。
## 5.1安全语言
我们首先定义用于编写模式的语言语法，然后定义如何对给定契约的语义分析解释模式（在第4节中描述）
## 5.1 Securify 语言
## 5.2 EVM背景和属性
为了理解下一节中定义的安全属性，我们扩展了EVM的背景知识（见4.1.1节），重点介绍了EVM语法，以及EVM契约的语义。
### EVM语义学
### 属性
## 5.3 安全属性和模式
我们现在定义了与EVM语义相关的七个安全属性[52]。 由于EVM是图灵完备的，因此无法精确检查这些属性。 相反，对于每个属性，我们定义了对我们语言的合规性和违规模式，这些模式过度接近了属性，并且分别对其否定。 也就是说，合规模式匹配意味着属性成立，违规模式匹配意味着属性的否定成立。 如果两个模式都不匹配，那么该属性可能会也可能不会成立。 在下文中，对于每个安全属性，我们描述其相关性，呈现其正式定义，然后将其细化为一组合规性和违规模式。 完整的属性和模式列表如图9所示
### Ether流动性
### 通话后没有写入
### 受限制的写作
## 5.4 通过违规模式进行错误定位
Securify的一个重要部分是查明导致违反（或潜在违规）安全属性的指令，因为这使开发人员能够修复代码。 在本节中，我们将描述哪些模式可以实现此类错误定位。 我们称这种模式为指令模式（因为它们精确定位指令），我们称其他模式为合约模式（因为违反是针对整个合约确定的）
# 6 实施
在本节中，我们将详细介绍Securify的实现。
### 反编译
反编译器将提供的EVM字节码转换为相应的汇编指令，如中所定义。接下来，它将EVM指令转换为SSA形式。 SSA指令与EVM指令集相同，除了它们排除堆栈操作（例如，弹出，推送等）。我们的转换方法类似于[45,51]中描述的方法。反编译器在反编译指令之上构造控制流图（CFG）。
### 优化
Securify对CFG进行了三次优化，提高了分析的准确性：
（i）未使用的指令，其中删除了未使用其结果的任何指令。平均而言，这种优化将合约的指令减少了44％，并提高了后续分析的可扩展性和精确度。
（ii）部分评估，沿计算传播常数值[29]。此步骤提高了存储和内存分析的精度（例如，MemTag）。正如我们在评估中所示，部分评估可以解决存储/内存指令中出现的70％以上的偏移。
（iii）方法内联，通过使其对上下文敏感来提高静态分析的精度。
### 语义分析的推断
Securify使用 Stratified Datalog中指定的推理规则导出语义分析，使用Souf-fle Datalog求解器[36]有效地计算所有事实的定点。我们在第7节报告具体数字。
### 评估模式
为了检查安全模式，Securify迭代了指令来处理模式中的所有和一些量词。然后，为了检查推断的事实，它直接查询由Datalog解算器计算的定点。如果匹配违规模式，Securify会报告哪些指令被识别为易受攻击，以便为用户提供错误定位。如果没有匹配的模式，Securify会报告一个警告，表明指令可能会或可能不会受到攻击。
# 7 评估
为了评估Securify，进行了以下实验：
（i）评估Securify在证实现实合约中的违规行为的正确性和发现方面的有效性; 
（ii）手动检查Securify在智能合约上的结果（即报告的违规和警告），其源代码已上载到Se- curify的公共接口; 
（iii）将Securify与Oyente 和Mythril 进行了比较，两个基于符号执行的智能合约检查员; 
（iv）测量了Securify反编译器在解决内存和存储偏移方面的成功; 测量Securify的时间和内存消耗。
### 数据集
我们使用两个智能合约数据集来评估Securify。 我们的第一个数据集，称为EVM数据集，由通过使用奇偶校验客户端解析创建事务获得的24,594个智能合约组成。 使用创建事务，我们获得了这些智能合约的EVM字节码。 我们的第二个数据集，称为Solidity数据集，由Solidity编写的100份智能合约组成，上载到Securify的公共界面。 为了避免偏见，我们在2018年按字母顺序选择了前100个合约。为了简化人工检查，我们将选择限制在最多200行Solidity代码的合约中。
![图片](https://images-cdn.shimo.im/wGtVZGgrxi4XLtfT/image.png!thumbnail)
>图11：EVM数据集上的Securify结果。 违规和合规部分表明每个安全财产被证明是安全/违规的指令。
![图片](https://images-cdn.shimo.im/LPJBtA7oRREXZyXX/image.png!thumbnail)
>图12：Solidity数据集上的Securify结果。 警告根据是否表示安全问题分为真假警告。

![图片](https://images-cdn.shimo.im/2bwjcO9OOCgvHM7o/image.png!thumbnail)
>图13：比较Securify与Oyente和Mythril
![图片](https://images-cdn.shimo.im/YsAtUtdX4tkWe8tn/image.png!thumbnail)
>图14：通过部分评估解决的偏移
### 评估结论
总的来说，我们的结果表明，Securify的模式在违规违规和建立正确的合约方面是有效的。 更进一步，我们看到了未来工作的两个相关项目。首先，将Securify与提供正式EVM语义的现有框架集合（例如[30,32]）作为进一步验证Securify的分析和模式的方法将是有趣的，并且正式证明 它提供的保证。 其次，我们可以利用Securify改进现有的符号检查器，例如Oyente和Mythril。 例如，Securify的合规模式可用于降低这些工具的误报率。
# 8 一些相关工作
智能合约分析
安全因素
基于语言的安全性
声明性程序分析
# 9结论
我们展示了Securify，这是一款针对以太坊智能合约的新型轻量级和可扩展的验证器。 
Securify利用特定领域的洞察力，即违反智能合约的许多实用属性也违反了更简单的属性，这些属性更加容易以纯粹自动化的方式进行检查。 基于这种洞察力，我们设定了合规性和违规模式，可以有效地证明现实合约在相关属性方面是否安全/不安全。 总的来说，Securify有几个重要的好处：
* 它分析所有合约行为，以避免不良的虚假否定;
* 通过保证某些行为是实际错误，减少了用户将警告分类为真阳性和误报的努力;
* 它支持一种新的DSL，使用户能够在出现新的漏洞模式时表达它们;
* 其分析管道 - 从字节码解码，优化到模式检查 - 使用可扩展的现成Datalog解算器完全自动化。
## 
